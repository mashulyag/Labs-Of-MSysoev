# Вопросы к Коллоквиуму по C++ по курсу "Алгоритмы и структуры данных"
\* - Вопросы только для тех, кто идёт на 5 в семестре. Претентенды на оценку будут известны в мае


## Указатели

- Какие операции есть у указателей?
- Что будет при сложении указателя с int?
- Как работает вычитание указателей?
- Что такое `void*`?
- Что такое `nullptr`? Отличие от `NULL`.
- Что такое динамическая память?
- Как работают операторы `new`, `new[]`, `delete`, `delete[]`

## Функции

- Зачем нужна перегрузка функций?
- Что такое `overloading resolution` и когда она применяется?
- Что такое `promotion` и `conversion` в overloading resolution?
- В каком порядке должны идти аргументы по умолчанию в функциях?

## Ссылки

- Что такое ссылка?
- Чем первое отличается от второго:
```c++
int a;
int b = a;
```

```c++
int a;
int& b = a;
```

- Что распечатается?
```C++
int x = 1;
int& y = x;
int& z = y;
int a = 0;
z = a;
std::cout << z << x << std::endl;
```

- Что тут не так?
```c++
std::string& hello(){
    std::string res = "Hello";
    return res;
}
```

## Const & static

- Что такое `static` переменная?
- Что такое `const` переменная?
- Что нельзя сделать с `const` переменной?
- Какая особенность у `const T*`?
- Зачем принимать по константной ссылке?

## Приведение типов

- Что такое `static_cast`?
- Что такое `reinterpret_cast` и почему он не рекомендуется к использованию?
- Что такое `const_cast` и почему он не рекомендуется к использованию?
- Что такое `C-style cast` и почему он не рекомендуется к использованию?

## Классы и объекты

- Чем классы отличаются от структур в C++?
- Что такое `this`?
- Что делает оператор `->`?
- Что делает конструктор копирования?
- Что такое `Shallow copy` и `Deep copy`?
- Что напечатается?
```C++
class A{
    A(){
        std::cout << "A\n";
    }
    ~A(){
        std::cout << "~A\n";
    }
}
class B{
    A a;
    B(){
        std::cout << "B\n";
    }
    ~B(){
        std::cout << "~B\n";
    }
}

main () {
    B b;
}

```

- Что нужно писать в деструкторах?
- Чем конструктор копирования отличается от оператора `=`?
- Как заставить компилятор сгенерировать констурктор по умолчанию?
- Как запретить компилятор генерировать констурктор по умолчанию?
- Что такое делегирующие конструкторы?*

## Перегрузка операторов

- Что должен делать оператор копирования?
- Что будет?
```C++
class String{
public:
    char* buffer;
    size_t sz;

    String() {
        buffer = new char[128];
    }

    ~String() {
        delete[] buffer;
    }

    String& operator=(const String& other){
        delete buffer;
        this->buffere = other.buffer;
        this->sz = other.sz;
    }
}

int main{
    String s;
    s = s;
}
```

- Как явно вызвать деструктор? Какие подводные камни у этого есть?
- Что такое `Copy and Swap`?
- Что такое правило трёх(и пяти)?
- Зачем нужны списки инициализации в конструкторах?
```C++
class String{
public:
    char* buffer;
    size_t sz;

    String(): sz(128), buffer(new char[128]) {}

```

- Что проиницилизируется первым в примере выше - buffer или sz?
- Что такое `Return Value Optimization(RVO)`?
- Почему `++Object` лучше `Object++`?
- Как перегружать операторы каста? Чтобы делать так:
```

int main(){
    String s = "124";
    int a = (int)s;
}

```

## Ключевые слова в методах

- Зачем нужны `const` методы? Какие у них свойства?
- Что такое ключевое слово `mutable`? Когда можно использовать?
- Что такое `static` поле?
- Что такое `static` метод?
- Что будет при `delete nullptr`?
- Ключевое слово `explicit` - зачем и когда использовать?


## Наследование*

- Что такое `public`, `private`, `protected` наследования?
- Как узнать получим ли мы доступ к Base переменной класса и вложенном наследовании?
- Как явно вызвать метод родителя у наследника?
- Можно ли унаследовать конструкторы?
- В каком порядке вызываются конструкторы и деструкторы при наследовании?
- Как инициализировать родителя при вызове конструктора наследника?
- Что такое `Empty Base Optimization`?
- Можно ли родителя кастовать к наследнику?
- Можно ли кастовать при private наследовании?

## Шаблоны (Templates)

- Что такое template и зачем он нужен?
- Чем `Typename T` отличается от `Class T`?
- Как работает перегрузка шаблонных функций?
- Как явно вызвать шаблонную функцию?
- Что такое специализация шаблона?
- Что такое частичная специализация?
- Шаблоны можно создавать только от типов?
- Можно ли в такие типы подставлять не const значения?
- Как можно сравнить два типа на этапе компиляции?
- Как убрать от объекта всё лишнее - `*`, `&`, `const` и т.д?
- Как работать с шаблонами от множества аргументов?


## Исключения

- Что происходит во время выполнения кода:
```C++
throw 1;
```
- Чем отличается exception от RE?
- Как поймать любое исключение?
- Какие два оператора в C++ имеют исключения?
- Создают ли копии объектов throw и catch?
- Производится ли касты типов в catch?
- Что такое RAII?
- Что такое noexcept?
- Что такое weak/strong exception safety?

## Итераторы в C++
- Что такое инвалидация итераторов?
- Какие есть типы итераторов?
- Что делает `std::advance`?
- Что делает `std::next`?
- Для чего используется `iterator_traits`?
- Что делает `std::distance`?

## Аллокаторы

- Зачем перегружать операторы new и delete?
- Как перегрузить глобальный new?
- Опишите, как работает new и delete?
- Как перегружать new/delete для своего класса?
- Как работает `placement new`?
- Что такое аллокатор?
- Зачем нужно `allocator_traits`?
- Какие бывают типы аллокаторов?

## Move-семантика
- Что делает `std::move`?
- Правило пяти
- Что такое `std::forward`?
- Что такое rvalue, lvalue, универсальные ссылки?

## Умные указатели
- Зачем нужны?
- Что делает `std::uniqie_ptr`?
- Что делает `std::shared_ptr`?
- Что делает `std::weak_ptr`?

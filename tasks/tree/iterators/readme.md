# Прошивка деревьев. Итераторы

## Пререквизиты

- [tree/bst](/tasks/tree/bst)

---

В этой задаче изменим свой `Map`, добавив в него итераторы.

## Дизайн

Классическим для списков дизайном итераторов является введение `Fake_Node` - служебной ноды, которая `не хранит в себе пользовательские данные!`

Для простоты мы будем реализовывать однонаправленные итераторы, позволяющие двигаться только вперед.

Есть три способа реализации итераторов:

### 1. Указатель на родителя
Зная указатель на родителя мы сможем лекго перемещаться вверх - вниз по дереву. Удобно, но жалко 8 байт для каждой ноды.

### 2. Прошивка (Threads)

Суть прошивки проста - заменить все правые nullptr на указатели на следующий по порядку узел.

Если мы хотим поддержать операции декримента, то аналогично нужно поддержать пустые левые указатели на предыдущий по порядку узел.

Прошитые деревья используют более сложные алгоритмы вставки и удаления, чтобы избежать затрат на хранение при добавлении родительских указателей. 

### 3. Корутины

Продвинутый уровень. Было бы классно иметь классическую функцию InOrder Bypass, которая при операции ++ `останавливалась`, а при повторном вызове функции вызывалась ровно с того места, где остановилась, сохранив при этом весь стек вызовов. Это и есть идея корутин. Например, ключевое слово `yield` в Python позвоялет это делать. Выглядело бы как-то так:
```c++
void InOrderBypass(Node* node) {
    if (node == nullptr) return;
    InOrderBypass(node->left);
    YIELD;
    InOrderBypass(node->right);
}
```


## Алгоритм прошивки дерева
В класс `Node` добавиться булевская переменная, показыващая является ли правый указатель нитью.

Как прошить готовое бинарое дерево поиска? Для этого будем использовать `std::stack`. Псевдокод будет выглядеть так:
```C++
if (node->right){
    is_right_link = false;
    st.push(node);
} else {
    is_right_link = true;
    node->right = st.top();
    st.pop();
    if (node->left) {
        st.push(node);
    }
}
```

## Про итераторы

Итераторы обходят дерево в порядке возрастания элементов. Следовательно:   
`Begin()` - возвращается итератор на минимальный элемент в дереве. Работает за O(logN)   
`End()` - возвращает итератор на Fake_node. Работает за O(1)   

### `operator++`
Если текущая node не была помечена как нить - идите максимально влево.

Иначе идите вправо.

---
### `Find`
Теперь мы возвращаем пользователю итератор на найденный элемент. Если элемента нет - возвращаем `End()`

## Задание

Измените [словарь](map.hpp), добавив в него итераторы с помощью прошивки дерева. Постарайтесь сохранять прошитость после вставки и удаления элементов из дерева.

### Указания к реализации

`Запрещено хранить указатель на родителя в Node!`

**В публичное API не стоит добавлять новых методов!**

**В публичном API не должно быть класса `Node`!**
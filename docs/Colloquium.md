# Вопросы к Коллоквиуму по C++ по курсу "Алгоритмы и структуры данных"
\* - Вопросы только для тех, кто идёт на 5 в семестре. Претентенды на оценку будут известны в мае


## Указатели

- Какие операции есть у указателей?
- Что будет при сложении указателя с int?
- Как работает вычитание указателей?
- Что такое `void*`?
- Что такое `nullptr`? Отличие от `NULL`.
- Что такое динамическая память?
- Как работают операторы `new`, `new[]`, `delete`, `delete[]`

## Функции

- Зачем нужна перегрузка функций?
- Что такое `overloading resolution` и когда она применяется?
- Что такое `promotion` и `conversion` в overloading resolution?
- В каком порядке должны идти аргументы по умолчанию в функциях?

## Ссылки

- Что такое ссылка?
- Чем первое отличается от второго:
```c++
int a;
int b = a;
```

```c++
int a;
int& b = a;
```

- Что распечатается?
```C++
int x = 1;
int& y = x;
int& z = y;
int a = 0;
z = a;
std::cout << z << x << std::endl;
```

- Что тут не так?
```c++
std::string& hello(){
    std::string res = "Hello";
    return res;
}
```

## Const & static

- Что такое `static` переменная?
- Что такое `const` переменная?
- Что нельзя сделать с `const` переменной?
- Какая особенность у `const T*`?
- Зачем принимать по константной ссылке?

## Приведение типов

- Что такое `static_cast`?
- Что такое `reinterpret_cast` и почему он не рекомендуется к использованию?
- Что такое `const_cast` и почему он не рекомендуется к использованию?
- Что такое `C-style cast` и почему он не рекомендуется к использованию?

## Классы и объекты

- Чем классы отличаются от структур в C++?
- Что такое `this`?
- Что делает оператор `->`?
- Что делает конструктор копирования?
- Что такое `Shallow copy` и `Deep copy`?
- Что напечатается?
```C++
class A{
    A(){
        std::cout << "A\n";
    }
    ~A(){
        std::cout << "~A\n";
    }
}
class B{
    A a;
    B(){
        std::cout << "B\n";
    }
    ~B(){
        std::cout << "~B\n";
    }
}

main () {
    B b;
}

```

- Что нужно писать в деструкторах?
- Чем конструктор копирования отличается от оператора `=`?
- Как заставить компилятор сгенерировать констурктор по умолчанию?
- Как запретить компилятор генерировать констурктор по умолчанию?
- Что такое делегирующие конструкторы?*

## Перегрузка операторов

- Что должен делать оператор копирования?
- Что будет?
```C++
class String{
public:
    char* buffer;
    size_t sz;

    String() {
        buffer = new char[128];
    }

    ~String() {
        delete[] buffer;
    }

    String& operator=(const String& other){
        delete buffer;
        this->buffere = other.buffer;
        this->sz = other.sz;
    }
}

int main{
    String s;
    s = s;
}
```

- Как явно вызвать деструктор? Какие подводные камни у этого есть?
- Что такое `Copy and Swap`?
- Что такое правило трёх(и пяти)?
- Зачем нужны списки инициализации в конструкторах?
```C++
class String{
public:
    char* buffer;
    size_t sz;

    String(): sz(128), buffer(new char[128]) {}

```

- Что проиницилизируется первым в примере выше - buffer или sz?
- Что такое `Return Value Optimization(RVO)`?
- Почему `++Object` лучше `Object++`?
- Как перегружать операторы каста? Чтобы делать так:
```

int main(){
    String s = "124";
    int a = (int)s;
}

```

## Ключевые слова в методах

- Зачем нужны `const` методы? Какие у них свойства?
- Что такое ключевое слово `mutable`? Когда можно использовать?
- Что такое `static` поле?
- Что такое `static` метод?
- Что будет при `delete nullptr`?
- Ключевое слово `explicit` - зачем и когда использовать?


## Наследование*

- Что такое `public`, `private`, `protected` наследования?
- Как узнать получим ли мы доступ к Base переменной класса и вложенном наследовании?
- Как явно вызвать метод родителя у наследника?
- Можно ли унаследовать конструкторы?
- В каком порядке вызываются конструкторы и деструкторы при наследовании?
- Как инициализировать родителя при вызове конструктора наследника?
- Что такое `Empty Base Optimization`?
- Можно ли родителя кастовать к наследнику?
- Можно ли кастовать при private наследовании?


